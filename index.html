<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: none;
    }

    .image-container {
      position: fixed;
      width: 180px;
      height: 180px;
      z-index: 9999999;
      pointer-events: none;

      /* Apply colour effect to the container (more reliable in messy CSS environments) */
      filter: hue-rotate(var(--hue, 0deg)) saturate(2) contrast(1.05) !important;
      transition: filter 140ms linear;
      will-change: left, top, transform, filter;
    }

    .image-container img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="image-container" id="imgBox">
    <img id="theImg" src="olive.png" alt="">
  </div>

  <script>
    const imgBox = document.getElementById('imgBox');

    // collision size (use your container size for easiest sanity)
    const imgWidth = 80;
    const imgHeight = 80;

    let pos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    let velocity = { x: 2.5, y: 2.5 };   // give it a starting push so it definitely hits walls
    const gravity = 0;                   // set to 0 while debugging
    const bounceFactor = 0.95;
    const repelForce = 15;
    let targetRotation = 0;

    let wasColliding = false;

    function randomiseHue() {
  const minHue = 30;
  const maxHue = 330;
  const hue = Math.floor(minHue + Math.random() * (maxHue - minHue));
  imgBox.style.setProperty('--hue', `${hue}deg`);
}

    randomiseHue();

    function updatePosition() {
      velocity.y += gravity;

      pos.x += velocity.x;
      pos.y += velocity.y;

      const minX = imgWidth / 2;
      const maxX = window.innerWidth - imgWidth / 2;
      const minY = imgHeight / 2;
      const maxY = window.innerHeight - imgHeight / 2;

      let collidedThisFrame = false;

      if (pos.x <= minX) {
        pos.x = minX;
        velocity.x = Math.abs(velocity.x) * bounceFactor;
        collidedThisFrame = true;
      } else if (pos.x >= maxX) {
        pos.x = maxX;
        velocity.x = -Math.abs(velocity.x) * bounceFactor;
        collidedThisFrame = true;
      }

      if (pos.y <= minY) {
        pos.y = minY;
        velocity.y = Math.abs(velocity.y) * bounceFactor;
        collidedThisFrame = true;
      } else if (pos.y >= maxY) {
        pos.y = maxY;
        velocity.y = -Math.abs(velocity.y) * bounceFactor;
        collidedThisFrame = true;
      }

      // Change colour only on "new" wall hit (not while stuck on the wall)
      if (collidedThisFrame && !wasColliding) {
        randomiseHue();
        console.log('bounce -> colour change'); // DEBUG: should print only on new hits
      }
      wasColliding = collidedThisFrame;

      imgBox.style.left = `${pos.x}px`;
      imgBox.style.top = `${pos.y}px`;
      imgBox.style.transform = `translate(-50%, -50%) rotate(${targetRotation}deg)`;

      // light damping
      velocity.x *= 0.999;
      velocity.y *= 0.999;

      requestAnimationFrame(updatePosition);
    }

    updatePosition();

    document.addEventListener('mousemove', (e) => {
      const rect = imgBox.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      const dx = e.clientX - centerX;
      const dy = e.clientY - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < 100) {
        const angle = Math.atan2(dy, dx);
        velocity.x -= Math.cos(angle) * repelForce;
        velocity.y -= Math.sin(angle) * repelForce;
        targetRotation = angle * (180 / Math.PI);
      }
    });

    window.addEventListener('resize', () => {
      const minX = imgWidth / 2;
      const maxX = window.innerWidth - imgWidth / 2;
      const minY = imgHeight / 2;
      const maxY = window.innerHeight - imgHeight / 2;

      pos.x = Math.min(Math.max(pos.x, minX), maxX);
      pos.y = Math.min(Math.max(pos.y, minY), maxY);
    });

    // DEBUG: manual colour change test
    // Run in console: document.getElementById('imgBox').style.setProperty('--hue', '180deg')
  </script>
</body>
</html>
